###  포인터

##### 메모리 주소 사용하기

```go
a := 2
b := a
fmt.Println(a, b)
```

a는 2이고, b는 a이다. 논리적으로 생각했을 때 출력 결과는 2와 2가 나온다. (b == a)

하지만 코드를 이렇게 바꾼다면?

```go
a := 2
b := a
a = 10
fmt.Println(a, b)
```

b는 a이지만 a의 값을 10으로 바꿨을 때 b는 10이 출력될까 2가 출력될까?

실행결과 :

> 10 2

a가 2인 상태에서 a를 복사해왔기 때문에 b에는 2라는 값이 저장된다.

a가 바뀌었을 때 b도 바뀌게 하고 싶다면 어떻게 해야할까?

```go
a := 3
b := &a
a = 5
fmt.Println(a, b)
```

'&' 키워드를 붙임으로써 a의 주소를 b에 저장할 수 있다.

이 상태로 출력하면 a 와 b는 같은 값을 출력할 것이다.

실행결과 :

> 5 0xc00001c0d0

b를 출력하자 진짜로 a의 주소를 출력해버린다..!



##### 주소 참조하기

주소에 있는 값을 사용하기 위해서는 '*' 를 사용해 주소에 접근해서 참조할 수 있다.

```go
a := 3
b := &a
a = 5
fmt.Println(a, *b)
```

*b는 "b에 들어있는 값이 주소인 곳의 값을 사용하겠어요~" 라고 생각하면 된다.

이 말을 풀어서 해석해보자면, 

> b에는 현재 0xc00001c0d0라는 값이 들어있는것과 마찬가지이다.
>
> 이 값은 a의 주소이므로 a의 값인 5를 사용하겠다는 것이다.

실행 결과는 다음과 같다.

> 5 5



##### 역참조

반대로 b를 가지고도 a의 값을 바꿀 수도 있다..!

b는 a의 주소를 가지고 있기 때문에 b의 주소의 값을 바꾸는건 a를 바꾸는것과 논리적으로 동일하다.

```go
a := 3
b := &a
*b = 5
fmt.Println(a, *b)
```

실행결과 :

> 5 5

*b는 a와 같고, b는 &a와 같다고 생각하면 된다.