### channel

##### 채널이란?

간단하게 데이터를 주고받는 통로라고 생각하면 된다.

보통 고루틴과 고루틴, 고루틴과 main 함수 사이의 데이터 송ㆍ수신을 위해 사용한다.



##### 채널 만들기

make() 함수를 이용해 만드는 편이다.

```go
var ch1 chan bool
ch2 := make(chan bool)
```

채널을 만들때에는 chan 키워드를 붙여주고 그 뒤에 타입을 적는다.



##### 데이터 보내고 받기

<- 키워드를 이용해 데이터를 주고받는다.

채널로 데이터를 보낼때는 <- (데이터), 받을때는 <- (채널이름) 처럼 사용한다.

```go
func what(c chan string) {
	c <- "what"
}
func main() {
	c := make(chan string)
    
	go what(c)
    fmt.Println(<-c)
}
```

간단하게 문자형 채널에 "what"을 보내고, 받은 출력해보았다.

그런데 생각해보면 go 키워드를 붙였을때는 비동기 처리가 되서 아래에 있는 <-c는 아직 아무것도 없지 않나..?

라고 생각할 수 있지만, Go는 똑똑하게도 채널에 데이터가 들어오기 전까지 main 함수의 진행을 중지시켜준다.



what 함수가 끝나기 전까지는 채널 안에 데이터가 없으므로 기다리고 있다가,

데이터가 들어오면 그때서야 출력시켜준다.



##### 버퍼링 채널

```go
func main() {
	c := make(chan string)
    
    func(){
        c <- "what"
    }()
    
    fmt.Println(<-c)
}
```

다음 코드의 실행 결과는 어떨까?

당연히 출력 결과는 what이 나올것이다.

하지만...?

>fatal error: all goroutines are asleep - deadlock!   

교착 상태에 빠졌다는 에러메시지를 출력한다.

함수에 go 키워드를 붙였을때는 자동으로 데이터가 들어오기 전까지 중지시켜주지만,

이렇게 동기적으로 진행되는 코드에서는 채널이 데이터를 지켜주지 않는다.

이럴때 채널의 버퍼를 설정해서 데이터를 받을 준비가 되어있지 않더라도 유동적으로 다른 일을 할수 있도록 해주는것이 버퍼링 채널이다.



```go
c := make(chan string, N)
```

N 자리에 들어가는 숫자만큼 채널의 버퍼가 생성된다.

앞에서 봤던 코드의 채널에 버퍼를 넣고 실행시키면 어떻게 될까?

```go
func main() {
	c := make(chan string, 1)
    
    func(){
        c <- "what"
    }()
    
    fmt.Println(<-c)
}
```

실행 결과 :

> what

기본적으로 make(chan Type)를 통해 생성된 채널은 0개의 버퍼를 가지고 있다.

그래서 go 키워드를 붙여주지 않으면 저장할 곳이 없기 때문에 교착 상태에 빠지게 되는 것이다.



##### 주의할 점

채널은 기본적으로 주고받는 행위가 있어야 하기 때문에, 채널의 버퍼 이상으로 값을 사용시 교착상태에 빠진다.

```go
func main() {
    a := make(chan string, 2)
	a <- "wwwwwhat"
	a <- "wwwhat"
	fmt.Println(<-a) //채널에 첫번째로 들어온 값
	fmt.Println(<-a) //채널에 두번째로 들어온 값
    fmt.Println(<-a) //언제 오지..?
}
```

버퍼가 2인 채널을 만들고, 동기적으로 채널에 문자열을 넣어주었다.

채널에 "wwwwhat", "wwwhat"이라는 문자열이 들어왔고, 채널을 출력하는 과정이 이루어진다.

먼저 들어온 문자열부터 출력한다면 두번째 출력문까진 올바르게 실행되지만, 세번째 출력문에서는 뻗어버린다.

a라는 채널에 들어오는 값이 없으므로(=a로 들어오는 세번째 내용물이 없으므로) 시스템이 채널로 들어오는 값을 기다리다 교착 상태에 빠지는 것이다.



여담으로 채널의 값이 아닌 채널 자체를 출력하면 다음과 같은 결과가 나온다.

```go
a := make(chan int)
fmt.Println(a)
```

실행 결과 : 

> 0xc0000240c0

주소의 형태인걸 보아 채널은 정말 값들이 이동하고 머무르는 중간 휴게소 느낌이 나는 것 같다.